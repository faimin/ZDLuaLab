---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Zero.D.Saber.
--- DateTime: 2019-07-01 12:57
---


----------------------------------------------------
--- table
----------------------------------------------------

--- map字典
---@param t table
---@param fn function func(k, v)
---@return table
function table.map(t, fn)
    for k, v in pairs(t) do
        t[k] = fn(k, v)
    end
    return t
end

--- 过滤table字典中的数据
---@param t table
---@param fn function func(k, v)
---@return table
function table.filter(t, fn)
    for k, v in pairs(t) do
        if not fn(k, v) then
            t[k] = nil
        end
    end
    return t
end

local function outputValue(value)
    if not value then
        return "nil"
    end

    local str, value_type
    value_type = type(value)
    if value_type == "number" then
        if (math.floor(value) < value) then
            str = string.format("[ %f ]n", tostring(value))
        else
            str = string.format("[ %d ]n", tostring(value))
        end
    elseif value_type == "string" then
        str = string.format("[ \"%s\" ]s", value)
    elseif value_type == "boolean" then
        str = string.format("[ \"%s\" ]b", tostring(value))
    elseif value_type == "table" then
        str = string.format("[ 0x%s ]t", string.sub(tostring(value), 8))
    elseif value_type == "function" then
        str = string.format("[ 0x%s ]f", string.sub(tostring(value), 11))
    elseif value_type == "userdata" then
        str = string.format("[ 0x%s ]u", string.sub(tostring(value), 11))
    else
        str = string.format("[ \"%s\" ]%s", tostring(value), type(value))
    end

    return str
end

function table.print(t, tname)
    if type(t) ~= "table" then
        print("table.error() not a table")
        return
    end

    local _deep_count = 0   -- 深度
    local printed_tables = {}
    local t_path = {}   -- 目录
    local outstr = ""   -- 输出字符串

    local print_one_table   -- 【关键函数】
    print_one_table = function(tb, tb_name)

        local tb_name = tb_name or "table"
        table.insert(t_path, tb_name)
        local tpath = ""
        for i, pname in ipairs(t_path) do
            tpath = tpath.."."..pname
        end

        printed_tables[tb] = tpath
        _deep_count = _deep_count + 1
        local str = ""
        local tab = string.rep(" ", _deep_count*4)  --返回重复4次空格的字符串
        outstr = outstr .. string.format("\n%s  {\n", tab);
        for k, v in pairs(tb) do
            if type(v) == "table" then
                if printed_tables[v] then
                    str = string.format("%s    %s = [ %s ]", tab, outputValue(k), printed_tables[v])
                    outstr = outstr..str.."\n"
                else
                    str = string.format("%s    %s = ", tab, outputValue(k))
                    outstr = outstr..str
                    print_one_table(v, tostring(k))
                end
            else
                str = string.format("%s    %s = %s", tab, outputValue(k), outputValue(v))
                outstr = outstr..str.."\n"
            end
        end
        outstr = outstr..tab.."  }\n"
        table.remove(t_path)
        _deep_count = _deep_count - 1
    end

    tname = tname or "root_table"
    print_one_table(t, tname)
    print(outstr)
    printed_tables = nil
end

----------------------------------------------------
--- string
----------------------------------------------------

--- 以指定字符把字符串拆分成字符串数组
---@param text string
---@param separateString string
---@return table
function string.split(text, separateString)
    if not separateString then
        return { text }
    end

    local patten = "[^" .. separateString .. "]+"
    local words = {}
    for s in string.gmatch(text, patten) do
        table.insert(words, s)
    end
    return words
end

---计算字符串长度，包含中文
---@param self string
---@return number
function string.length(self)
    if not self or type(self) ~= "string" then
        return 0
    end

    local lenInByte = #self
    local charCount = 0
    local i = 1
    while (i <= lenInByte) do
        local curByte = string.byte(self, i)
        
        local byteCount = 1
        if curByte > 0 and curByte <= 127 then
            byteCount = 1                                               --1字节字符
        elseif curByte >= 192 and curByte < 223 then
            byteCount = 2                                               --双字节字符
        elseif curByte >= 224 and curByte <= 239 then
            byteCount = 3                                               --汉字
        elseif curByte >= 240 and curByte <= 247 then
            byteCount = 4                                               --4字节字符
        end

        local char = string.sub(self, i, i + byteCount - 1)
        i = i + byteCount                                               -- 重置下一字节的索引
        charCount = charCount + 1                                       -- 字符的个数（长度）
    end

    return charCount
end

----------------------------------------------------
--- function
----------------------------------------------------

--- 打印函数位置
function LogFuncPosition()
    local info = debug.getinfo(2)
    local line = info.currentline
    local file = info.short_src
    local func = info.name
    local positionString = string.format("file = %s, line = #%d, func = %s", file, line, func)
    print(positionString)
end

--- shallowCopy
--- http://lua-users.org/wiki/CopyTable
---@param orig table
---@return table
function ShallowCopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in pairs(orig) do
            copy[orig_key] = orig_value
        end
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

--- A deep copy copies all levels (or a specific subset of levels).
--- http://lua-users.org/wiki/CopyTable
---@param orig table
---@return table
function DeepCopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[DeepCopy(orig_key)] = DeepCopy(orig_value)
        end
        setmetatable(copy, DeepCopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

--- Save copied tables in `copies`, indexed by original table.
--- http://lua-users.org/wiki/CopyTable
---@param orig table
---@param copies table
---@return table
function DeepCopyToTable(orig, copies)
    copies = copies or {}
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        if copies[orig] then
            copy = copies[orig]
        else
            copy = {}
            copies[orig] = copy
            for orig_key, orig_value in next, orig, nil do
                copy[DeepCopyToTable(orig_key, copies)] = DeepCopyToTable(orig_value, copies)
            end
            setmetatable(copy, DeepCopyToTable(getmetatable(orig), copies))
        end
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end